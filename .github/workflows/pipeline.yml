name: Directus CI/CD Pipeline

on:
  push:
    branches: [main, master]
  workflow_dispatch:

env:
  TF_VERSION: "1.7.0"

jobs:
  # ─────────────────────────────────────────
  # STAGE 1: VALIDATE
  # ─────────────────────────────────────────
  terraform_validate:
    name: "Validate: Terraform"
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: terraform
    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Terraform Init
        run: |
          set -eo pipefail
          terraform init -backend=false

      - name: Terraform Validate
        run: |
          set -eo pipefail
          terraform validate

  terraform_lint:
    name: "Validate: TFLint"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: terraform-linters/setup-tflint@v4
        with:
          tflint_version: latest

      - name: TFLint Init
        run: |
          set -eo pipefail
          tflint --init
        working-directory: terraform
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Run TFLint
        run: |
          set -o pipefail
          tflint --chdir=terraform --format=compact 2>&1 | tee lint_report.txt || true

  docker_validate:
    name: "Validate: Docker Compose"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Validate docker-compose.yml
        run: |
          set -eo pipefail
          docker compose -f docker-compose.yml config --quiet

  # ─────────────────────────────────────────
  # STAGE 2: PLAN
  # ─────────────────────────────────────────
  terraform_plan:
    name: "Plan: Terraform"
    runs-on: ubuntu-latest
    needs: [terraform_validate, terraform_lint, docker_validate]
    defaults:
      run:
        working-directory: terraform
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: ${{ secrets.AWS_DEFAULT_REGION }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Terraform Init
        run: terraform init -backend=false

      - name: Terraform Plan
        run: |
          set -eo pipefail
          terraform plan \
            -var="aws_region=${{ secrets.AWS_DEFAULT_REGION }}" \
            -var="ami_id=ami-0b6c6ebed2801a5cb" \
            -var="project_name=directus-cicd" \
            -var="instance_type=t2.micro" \
            -var="environment=production" \
            -no-color 2>&1 | tee plan_output.txt

      - name: Upload plan output
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-output
          path: terraform/plan_output.txt
          retention-days: 7

  # ─────────────────────────────────────────
  # STAGE 3: PROVISION
  # ─────────────────────────────────────────
  terraform_apply:
    name: "Provision: Terraform Apply"
    runs-on: ubuntu-latest
    needs: [terraform_plan]
    environment: production
    defaults:
      run:
        working-directory: terraform
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: ${{ secrets.AWS_DEFAULT_REGION }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Terraform Init
        run: terraform init -backend=false

      - name: Terraform Apply
        run: |
          set -eo pipefail
          terraform apply \
            -var="aws_region=${{ secrets.AWS_DEFAULT_REGION }}" \
            -var="ami_id=ami-0b6c6ebed2801a5cb" \
            -var="project_name=directus-cicd" \
            -var="instance_type=t2.micro" \
            -var="environment=production" \
            -state=terraform.tfstate \
            -auto-approve \
            -no-color 2>&1 | tee apply_output.txt

      - name: Extract Outputs
        run: |
          set -eo pipefail
          SERVER_IP=$(terraform output -state=terraform.tfstate -raw instance_public_ip)
          echo "$SERVER_IP" > ../server_ip.txt
          
          terraform output -state=terraform.tfstate -raw private_key_pem > ../ssh_key.pem
          chmod 600 ../ssh_key.pem
          
          terraform output -state=terraform.tfstate -raw directus_url > ../directus_url.txt
          
          echo "Provisioned IP: $SERVER_IP"
          echo "Waiting 120s for EC2 initialization..."
          sleep 120

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: server-connection-details
          path: |
            server_ip.txt
            ssh_key.pem
            directus_url.txt
            terraform/terraform.tfstate
          retention-days: 1

  # ─────────────────────────────────────────
  # STAGE 4: DEPLOY
  # ─────────────────────────────────────────
  deploy_directus:
    name: "Deploy: Directus via SSH"
    runs-on: ubuntu-latest
    needs: [terraform_apply]
    steps:
      - uses: actions/checkout@v4

      - name: Download connection artifacts
        uses: actions/download-artifact@v4
        with:
          name: server-connection-details

      - name: Detect SSH User and Wait
        run: |
          set -eo pipefail
          SERVER_IP=$(cat server_ip.txt)
          chmod 600 ssh_key.pem
          
          USERS=("ubuntu" "ec2-user" "admin" "root")
          DETECTED_USER=""
          
          for i in $(seq 1 30); do
            for user in "${USERS[@]}"; do
              echo "Trying $user@$SERVER_IP..."
              if ssh -i ssh_key.pem -o ConnectTimeout=5 -o StrictHostKeyChecking=no "$user@$SERVER_IP" "echo SSH_OK" 2>/dev/null; then
                echo "$user" > ssh_user.txt
                DETECTED_USER=$user
                echo "Success: User is $user"
                break 2
              fi
            done
            sleep 15
          done
          
          if [ -z "$DETECTED_USER" ]; then exit 1; fi

      - name: Wait for Docker
        run: |
          set -eo pipefail
          SERVER_IP=$(cat server_ip.txt)
          SSH_USER=$(cat ssh_user.txt)
          for i in $(seq 1 20); do
            if ssh -i ssh_key.pem -o StrictHostKeyChecking=no "$SSH_USER@$SERVER_IP" "docker info >/dev/null 2>&1"; then
              echo "Docker ready!"
              break
            fi
            sleep 20
          done

      - name: Deploy Containers
        run: |
          set -eo pipefail
          SERVER_IP=$(cat server_ip.txt)
          SSH_USER=$(cat ssh_user.txt)
          
          ssh -i ssh_key.pem -o StrictHostKeyChecking=no "$SSH_USER@$SERVER_IP" "mkdir -p ~/directus"
          scp -i ssh_key.pem -o StrictHostKeyChecking=no docker-compose.yml "$SSH_USER@$SERVER_IP:~/directus/docker-compose.yml"
          
          # Use EOF without quotes to allow variable expansion of SERVER_IP
          # BUT we must escape the $ in secrets to prevent them from being expanded locally by shell if they contain $
          ssh -i ssh_key.pem -o StrictHostKeyChecking=no "$SSH_USER@$SERVER_IP" "cat << EOF > ~/directus/.env
          ADMIN_EMAIL=${{ secrets.ADMIN_EMAIL }}
          ADMIN_PASSWORD=${{ secrets.ADMIN_PASSWORD }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          SECRET=${{ secrets.DIRECTUS_SECRET }}
          SERVER_IP=$SERVER_IP
          EOF"
          
          ssh -i ssh_key.pem -o StrictHostKeyChecking=no "$SSH_USER@$SERVER_IP" "cd ~/directus && docker compose up -d"

      - name: Health Check
        run: |
          SERVER_IP=$(cat server_ip.txt)
          for i in $(seq 1 20); do
            if curl -s -o /dev/null -w "%{http_code}" "http://$SERVER_IP:8055/server/ping" | grep -q "200"; then
              echo "Directus is up!"
              exit 0
            fi
            sleep 15
          done
          exit 1

      - name: Collect logs
        if: always()
        run: |
          SERVER_IP=$(cat server_ip.txt)
          SSH_USER=$(cat ssh_user.txt)
          ssh -i ssh_key.pem -o StrictHostKeyChecking=no "$SSH_USER@$SERVER_IP" "cd ~/directus && docker compose ps && docker compose logs --tail=100" > deployment.log || true

      - name: Upload deployment logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-logs
          path: deployment.log

  # ─────────────────────────────────────────
  # STAGE 5: TEST
  # ─────────────────────────────────────────
  test:
    name: "Verification"
    runs-on: ubuntu-latest
    needs: [deploy_directus]
    steps:
      - name: Download connection artifacts
        uses: actions/download-artifact@v4
        with:
          name: server-connection-details

      - name: Homepage Capture
        run: |
          SERVER_IP=$(cat server_ip.txt)
          curl -L -o homepage.html "http://$SERVER_IP:8055"
          
      - name: Upload Homepage
        uses: actions/upload-artifact@v4
        with:
          name: directus-homepage
          path: homepage.html

  # ─────────────────────────────────────────
  # STAGE 6: CLEANUP (MANUAL)
  # ─────────────────────────────────────────
  cleanup:
    name: "Cleanup"
    runs-on: ubuntu-latest
    needs: [test]
    environment: cleanup
    defaults:
      run:
        working-directory: terraform
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: ${{ secrets.AWS_DEFAULT_REGION }}
    steps:
      - uses: actions/checkout@v4
      - name: Download state
        uses: actions/download-artifact@v4
        with:
          name: server-connection-details
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false
      - name: Restore State
        run: |
          # The artifact contains 'terraform/terraform.tfstate'
          # If download-artifact v4 keeps structure, it might be in ../terraform/terraform.tfstate
          # or just ../terraform.tfstate
          find .. -name "terraform.tfstate" -exec cp {} . \;
      - name: Terraform Init
        run: terraform init -backend=false
      - name: Terraform Destroy
        run: |
          terraform destroy \
            -var="aws_region=${{ secrets.AWS_DEFAULT_REGION }}" \
            -var="ami_id=ami-0b6c6ebed2801a5cb" \
            -var="project_name=directus-cicd" \
            -var="instance_type=t2.micro" \
            -var="environment=production" \
            -state=terraform.tfstate \
            -auto-approve
