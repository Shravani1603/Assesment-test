name: Directus CI/CD Pipeline

on:
  push:
    branches: [main, master]
  workflow_dispatch:

env:
  TF_VERSION: "1.7.0"
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  # ─────────────────────────────────────────
  # STAGE 1: VALIDATE
  # ─────────────────────────────────────────
  terraform_validate:
    name: "Validate: Terraform"
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: terraform
    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Terraform Init
        run: |
          set -eo pipefail
          terraform init -backend=false

      - name: Terraform Format Check
        run: terraform fmt -check -recursive

      - name: Terraform Validate
        run: |
          set -eo pipefail
          terraform validate

  terraform_lint:
    name: "Validate: TFLint"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: terraform-linters/setup-tflint@v4
        with:
          tflint_version: latest

      - name: TFLint Init
        run: |
          set -eo pipefail
          tflint --init
        working-directory: terraform

      - name: Run TFLint
        run: |
          set -o pipefail
          tflint --chdir=terraform --format=compact 2>&1 | tee lint_report.txt || true

  docker_validate:
    name: "Validate: Docker Compose"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Validate docker-compose.yml
        run: |
          set -eo pipefail
          docker compose -f docker-compose.yml config --quiet

  # ─────────────────────────────────────────
  # STAGE 2: PLAN
  # ─────────────────────────────────────────
  terraform_plan:
    name: "Plan: Terraform"
    runs-on: ubuntu-latest
    needs: [terraform_validate, terraform_lint, docker_validate]
    defaults:
      run:
        working-directory: terraform
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: ${{ secrets.AWS_DEFAULT_REGION }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Terraform Init
        run: terraform init -backend=false

      - name: Terraform Plan
        run: |
          set -eo pipefail
          terraform plan \
            -var="aws_region=${{ secrets.AWS_DEFAULT_REGION }}" \
            -var="ami_id=ami-0b6c6ebed2801a5cb" \
            -var="project_name=directus-cicd" \
            -var="instance_type=t2.micro" \
            -var="environment=production" \
            -no-color 2>&1 | tee plan_output.txt

      - name: Upload plan output
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-output
          path: terraform/plan_output.txt
          retention-days: 7

  # ─────────────────────────────────────────
  # STAGE 3: PROVISION (MANUAL via Environment)
  # ─────────────────────────────────────────
  terraform_apply:
    name: "Provision: Terraform Apply"
    runs-on: ubuntu-latest
    needs: [terraform_plan]
    environment: production
    defaults:
      run:
        working-directory: terraform
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: ${{ secrets.AWS_DEFAULT_REGION }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Terraform Init
        run: terraform init -backend=false

      - name: Terraform Apply
        id: apply
        run: |
          set -eo pipefail
          terraform apply \
            -var="aws_region=${{ secrets.AWS_DEFAULT_REGION }}" \
            -var="ami_id=ami-0b6c6ebed2801a5cb" \
            -var="project_name=directus-cicd" \
            -var="instance_type=t2.micro" \
            -var="environment=production" \
            -state=terraform.tfstate \
            -auto-approve \
            -no-color 2>&1 | tee apply_output.txt

      - name: Extract and Verify Outputs
        run: |
          set -eo pipefail
          echo "=== Verifying State File ==="
          ls -l terraform.tfstate
          
          echo "=== Extracting IP ==="
          SERVER_IP=$(terraform output -state=terraform.tfstate -raw instance_public_ip)
          if [ -z "$SERVER_IP" ]; then
            echo "ERROR: Server IP is empty!"
            exit 1
          fi
          echo "Server IP: $SERVER_IP"
          echo "$SERVER_IP" > ../server_ip.txt

          echo "=== Extracting Private Key ==="
          terraform output -state=terraform.tfstate -raw private_key_pem > ../ssh_key.pem
          chmod 600 ../ssh_key.pem
          if [ ! -s ../ssh_key.pem ]; then
            echo "ERROR: Private key file is empty!"
            exit 1
          fi

          terraform output -state=terraform.tfstate -raw directus_url > ../directus_url.txt
          
          echo "=== Extracting Other Details ==="
          terraform output -state=terraform.tfstate -raw vpc_id > ../vpc_id.txt
          terraform output -state=terraform.tfstate -raw subnet_id > ../subnet_id.txt

          echo "=== Infrastructure successfully provisioned ==="
          echo "Waiting 150s for EC2 initialization..."
          sleep 150

      - name: Upload connection artifacts
        uses: actions/upload-artifact@v4
        with:
          name: server-connection-details
          path: |
            server_ip.txt
            ssh_key.pem
            directus_url.txt
            vpc_id.txt
            subnet_id.txt
            terraform/apply_output.txt
            terraform/terraform.tfstate
          retention-days: 1

  # ─────────────────────────────────────────
  # STAGE 4: DEPLOY
  # ─────────────────────────────────────────
  deploy_directus:
    name: "Deploy: Directus via SSH"
    runs-on: ubuntu-latest
    needs: [terraform_apply]
    steps:
      - uses: actions/checkout@v4

      - name: Download connection artifacts
        uses: actions/download-artifact@v4
        with:
          name: server-connection-details

      - name: Verify IP
        run: |
          SERVER_IP=$(cat server_ip.txt)
          if [ -z "$SERVER_IP" ]; then
            echo "ERROR: server_ip.txt is empty. Apply job failed to pass IP."
            exit 1
          fi
          echo "Deploying to IP: $SERVER_IP"

      - name: Detect SSH User and Wait for SSH
        run: |
          set -eo pipefail
          SERVER_IP=$(cat server_ip.txt)
          chmod 600 ssh_key.pem
          
          echo "Detecting SSH user..."
          USERS=("ubuntu" "ec2-user" "admin" "root")
          DETECTED_USER=""
          
          for i in $(seq 1 40); do
            for user in "${USERS[@]}"; do
              echo "Attempt $i/40: Trying user $user..."
              if ssh -i ssh_key.pem -o ConnectTimeout=5 -o StrictHostKeyChecking=no "$user@$SERVER_IP" "echo SSH_OK" 2>/dev/null; then
                echo "Success! SSH user is $user"
                DETECTED_USER=$user
                echo "$user" > ssh_user.txt
                break 2
              fi
            done
            echo "No user ready yet. Waiting 15s..."
            sleep 15
          done
          
          if [ -z "$DETECTED_USER" ]; then
            echo "ERROR: Could not connect via SSH after 40 attempts."
            exit 1
          fi

      - name: Wait for Docker
        run: |
          set -eo pipefail
          SERVER_IP=$(cat server_ip.txt)
          SSH_USER=$(cat ssh_user.txt)
          echo "Waiting for Docker with user $SSH_USER on $SERVER_IP..."
          
          for i in $(seq 1 20); do
            if ssh -i ssh_key.pem -o StrictHostKeyChecking=no "$SSH_USER@$SERVER_IP" "docker info >/dev/null 2>&1"; then
              echo "Docker is ready!"
              ssh -i ssh_key.pem -o StrictHostKeyChecking=no "$SSH_USER@$SERVER_IP" "docker --version"
              break
            fi
            echo "Docker not ready yet ($i/20). Waiting 20s..."
            sleep 20
            if [ $i -eq 20 ]; then
                echo "ERROR: Docker failed to start within timeout. Checking user_data logs..."
                ssh -i ssh_key.pem -o StrictHostKeyChecking=no "$SSH_USER@$SERVER_IP" "sudo cat /var/log/cloud-init-output.log" || true
                exit 1
            fi
          done

      - name: SSH Deployment
        run: |
          set -eo pipefail
          SERVER_IP=$(cat server_ip.txt)
          SSH_USER=$(cat ssh_user.txt)
          
          echo "=== Copying docker-compose.yml ==="
          ssh -i ssh_key.pem -o StrictHostKeyChecking=no "$SSH_USER@$SERVER_IP" "mkdir -p ~/directus"
          scp -i ssh_key.pem -o StrictHostKeyChecking=no docker-compose.yml "$SSH_USER@$SERVER_IP:~/directus/docker-compose.yml"
          
          echo "=== Generating .env ==="
          ssh -i ssh_key.pem -o StrictHostKeyChecking=no "$SSH_USER@$SERVER_IP" "cat << 'EOF' > ~/directus/.env
          ADMIN_EMAIL=${{ secrets.ADMIN_EMAIL }}
          ADMIN_PASSWORD=${{ secrets.ADMIN_PASSWORD }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          SECRET=${{ secrets.DIRECTUS_SECRET }}
          SERVER_IP=$SERVER_IP
          EOF"
          
          echo "=== Starting Containers ==="
          ssh -i ssh_key.pem -o StrictHostKeyChecking=no "$SSH_USER@$SERVER_IP" "cd ~/directus && docker compose up -d"
          
          echo "=== Health Checking Port 8055 ==="
          for i in $(seq 1 30); do
            if curl -s -o /dev/null -w "%{http_code}" "http://$SERVER_IP:8055/server/ping" | grep -q "200"; then
              echo "Directus is up!"
              break
            fi
            echo "Waiting for Directus... ($i/30)"
            sleep 15
          done

      - name: Upload Logs
        if: always()
        run: |
          SERVER_IP=$(cat server_ip.txt)
          SSH_USER=$(cat ssh_user.txt)
          ssh -i ssh_key.pem -o StrictHostKeyChecking=no "$SSH_USER@$SERVER_IP" "cd ~/directus && docker compose ps && docker compose logs --tail=100" > deployment.log || true
        uses: actions/upload-artifact@v4
        with:
          name: deployment-logs
          path: deployment.log

  # ─────────────────────────────────────────
  # STAGE 5: TEST
  # ─────────────────────────────────────────
  test:
    name: "Final Verification"
    runs-on: ubuntu-latest
    needs: [deploy_directus]
    steps:
      - name: Download connection artifacts
        uses: actions/download-artifact@v4
        with:
          name: server-connection-details

      - name: Health Check
        run: |
          SERVER_IP=$(cat server_ip.txt)
          curl -f -i "http://$SERVER_IP:8055/server/ping"

      - name: Capture Homepage
        run: |
          SERVER_IP=$(cat server_ip.txt)
          curl -L -o homepage.html "http://$SERVER_IP:8055"
          
      - name: Upload Homepage
        uses: actions/upload-artifact@v4
        with:
          name: directus-homepage
          path: homepage.html

  # ─────────────────────────────────────────
  # STAGE 6: CLEANUP (MANUAL)
  # ─────────────────────────────────────────
  cleanup:
    name: "Cleanup: Terraform Destroy"
    runs-on: ubuntu-latest
    needs: [test]
    environment: cleanup
    defaults:
      run:
        working-directory: terraform
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: ${{ secrets.AWS_DEFAULT_REGION }}
    steps:
      - uses: actions/checkout@v4
      - name: Download Connection Details (State)
        uses: actions/download-artifact@v4
        with:
          name: server-connection-details
      - name: Restore State
        run: cp ../terraform/terraform.tfstate . || true
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false
      - name: Terraform Init
        run: terraform init -backend=false
      - name: Terraform Destroy
        run: |
          terraform destroy \
            -var="aws_region=${{ secrets.AWS_DEFAULT_REGION }}" \
            -var="ami_id=ami-0b6c6ebed2801a5cb" \
            -var="project_name=directus-cicd" \
            -var="instance_type=t2.micro" \
            -var="environment=production" \
            -state=terraform.tfstate \
            -auto-approve
