stages:
  - validate
  - plan
  - provision
  - deploy
  - test
  - cleanup

# ─────────────────────────────────────────────────────────────
# Default settings shared across jobs
# ─────────────────────────────────────────────────────────────
default:
  before_script:
    - echo "Starting job $CI_JOB_NAME in stage $CI_JOB_STAGE"

variables:
  TF_ROOT: "${CI_PROJECT_DIR}/terraform"
  AWS_DEFAULT_REGION: "${AWS_DEFAULT_REGION}"

# ─────────────────────────────────────────────────────────────
# STAGE 1: VALIDATE
# ─────────────────────────────────────────────────────────────

terraform_validate:
  stage: validate
  image: hashicorp/terraform:latest
  before_script:
    - cd ${TF_ROOT}
    - terraform init -backend=false
  script:
    - echo "=== Terraform Format Check ==="
    - terraform fmt -check -recursive
    - echo "=== Terraform Validate ==="
    - terraform validate
    - echo "Terraform validation passed!" | tee validation_report.txt
  artifacts:
    name: "terraform-validation-${CI_COMMIT_SHORT_SHA}"
    paths:
      - terraform/validation_report.txt
    expire_in: 7 days
    when: always
  rules:
    - when: always

terraform_lint:
  stage: validate
  image: ghcr.io/terraform-linters/tflint:latest
  before_script:
    - cd ${TF_ROOT}
    - tflint --init || true
  script:
    - echo "=== TFLint Check ==="
    - tflint --chdir=${TF_ROOT} --format=compact 2>&1 | tee ${CI_PROJECT_DIR}/lint_report.txt || true
    - echo "TFLint completed" >> ${CI_PROJECT_DIR}/lint_report.txt
  artifacts:
    name: "terraform-lint-${CI_COMMIT_SHORT_SHA}"
    paths:
      - lint_report.txt
    expire_in: 7 days
    when: always
  rules:
    - when: always

docker_validate:
  stage: validate
  image: docker:latest
  services:
    - docker:dind
  variables:
    DOCKER_TLS_CERTDIR: ""
    DOCKER_HOST: "tcp://docker:2375"
  before_script:
    - docker info
    - apk add --no-cache docker-compose || true
  script:
    - echo "=== Docker Compose Validate ==="
    - docker compose -f ${CI_PROJECT_DIR}/docker-compose.yml config --quiet 2>&1 | tee compose_config_report.txt || true
    - echo "docker-compose.yml syntax validated" | tee -a compose_config_report.txt
  artifacts:
    name: "docker-validate-${CI_COMMIT_SHORT_SHA}"
    paths:
      - compose_config_report.txt
    expire_in: 7 days
    when: always
  rules:
    - when: always

# ─────────────────────────────────────────────────────────────
# STAGE 2: PLAN
# ─────────────────────────────────────────────────────────────

terraform_plan:
  stage: plan
  image: hashicorp/terraform:latest
  before_script:
    - cd ${TF_ROOT}
    - terraform init -backend=false
  script:
    - echo "=== Terraform Plan ==="
    - terraform plan
        -var="aws_region=${AWS_DEFAULT_REGION}"
        -var="project_name=directus-cicd"
        -var="instance_type=t2.micro"
        -var="environment=production"
        -out=tfplan
        -no-color 2>&1 | tee plan_output.txt
    - echo "Terraform plan completed successfully!"
  artifacts:
    name: "terraform-plan-${CI_COMMIT_SHORT_SHA}"
    paths:
      - terraform/tfplan
      - terraform/plan_output.txt
    expire_in: 7 days
  rules:
    - when: always
  dependencies: []

# ─────────────────────────────────────────────────────────────
# STAGE 3: PROVISION (MANUAL)
# ─────────────────────────────────────────────────────────────

terraform_apply:
  stage: provision
  image: hashicorp/terraform:latest
  before_script:
    - cd ${TF_ROOT}
    - terraform init -backend=false
  script:
    - echo "=== Terraform Apply ==="
    - terraform apply
        -var="aws_region=${AWS_DEFAULT_REGION}"
        -var="project_name=directus-cicd"
        -var="instance_type=t2.micro"
        -var="environment=production"
        -auto-approve
        -no-color 2>&1 | tee apply_output.txt
    - echo "=== Extracting Outputs ==="
    # Extract server IP
    - terraform output -raw instance_public_ip > ${CI_PROJECT_DIR}/server_ip.txt
    - cat ${CI_PROJECT_DIR}/server_ip.txt
    # Extract private key (sensitive)
    - terraform output -raw private_key_pem > ${CI_PROJECT_DIR}/ssh_key.pem
    - chmod 600 ${CI_PROJECT_DIR}/ssh_key.pem
    # Extract Directus URL
    - terraform output -raw directus_url > ${CI_PROJECT_DIR}/directus_url.txt
    - cat ${CI_PROJECT_DIR}/directus_url.txt
    - echo "=== Infrastructure Provisioned Successfully ==="
    - echo "Server IP $(cat ${CI_PROJECT_DIR}/server_ip.txt)"
    - echo "Directus URL $(cat ${CI_PROJECT_DIR}/directus_url.txt)"
    # Wait for instance to be SSH-ready
    - echo "Waiting 90s for EC2 instance to boot and Docker to install..."
    - sleep 90
  artifacts:
    name: "terraform-apply-${CI_COMMIT_SHORT_SHA}"
    paths:
      - terraform/apply_output.txt
      - server_ip.txt
      - ssh_key.pem
      - directus_url.txt
    expire_in: 1 day
  rules:
    - when: manual
  allow_failure: false

# ─────────────────────────────────────────────────────────────
# STAGE 4: DEPLOY
# ─────────────────────────────────────────────────────────────

deploy_directus:
  stage: deploy
  image: alpine:latest
  dependencies:
    - terraform_apply
  before_script:
    - apk add --no-cache openssh-client curl bash
    - SERVER_IP=$(cat ${CI_PROJECT_DIR}/server_ip.txt)
    - echo "Deploying to server IP $SERVER_IP"
    # Configure SSH
    - mkdir -p ~/.ssh
    - cp ${CI_PROJECT_DIR}/ssh_key.pem ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - ssh-keyscan -H $SERVER_IP >> ~/.ssh/known_hosts 2>/dev/null || true
    - echo "StrictHostKeyChecking no" >> ~/.ssh/config
    - echo "UserKnownHostsFile /dev/null" >> ~/.ssh/config
  script:
    - SERVER_IP=$(cat ${CI_PROJECT_DIR}/server_ip.txt)
    - echo "=== Waiting for SSH to be available ==="
    - |
      for i in $(seq 1 30); do
        if ssh -i ~/.ssh/id_rsa -o ConnectTimeout=5 -o StrictHostKeyChecking=no ubuntu@$SERVER_IP "echo SSH_OK" 2>/dev/null; then
          echo "SSH is ready!"
          break
        fi
        echo "Attempt $i/30: SSH not ready yet, waiting 15s..."
        sleep 15
      done
    - echo "=== Wait for Docker to be ready ==="
    - |
      for i in $(seq 1 20); do
        if ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ubuntu@$SERVER_IP "docker info >/dev/null 2>&1" 2>/dev/null; then
          echo "Docker is ready!"
          break
        fi
        echo "Attempt $i/20: Docker not ready yet, waiting 20s..."
        sleep 20
      done
    - echo "=== Copying docker-compose.yml to server ==="
    - scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ${CI_PROJECT_DIR}/docker-compose.yml ubuntu@$SERVER_IP:/home/ubuntu/directus/docker-compose.yml
    - echo "=== Generating .env file on server ==="
    - |
      ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ubuntu@$SERVER_IP "
        cat > /home/ubuntu/directus/.env << 'ENVEOF'
      ADMIN_EMAIL=${ADMIN_EMAIL}
      ADMIN_PASSWORD=${ADMIN_PASSWORD}
      DB_PASSWORD=${DB_PASSWORD}
      SECRET=${DIRECTUS_SECRET}
      SERVER_IP=${SERVER_IP}
      ENVEOF
        echo '.env file created'
        cat /home/ubuntu/directus/.env | sed 's/=.*/=***MASKED***/g'
      "
    - echo "=== Starting Directus via Docker Compose ==="
    - |
      ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ubuntu@$SERVER_IP "
        cd /home/ubuntu/directus
        docker compose up -d
        echo 'Docker Compose started'
      "
    - echo "=== Waiting for Directus to become healthy ==="
    - |
      for i in $(seq 1 30); do
        STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://$SERVER_IP:8055/server/ping 2>/dev/null || echo "000")
        echo "Attempt $i/30: Directus health check returned HTTP $STATUS"
        if [ "$STATUS" = "200" ]; then
          echo "Directus is healthy!"
          break
        fi
        sleep 20
      done
    - echo "=== Deployment completed ==="
    - echo "Directus is accessible at http://$SERVER_IP:8055"
    - |
      ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ubuntu@$SERVER_IP "
        cd /home/ubuntu/directus
        docker compose ps
        docker compose logs --tail=20 directus
      " 2>&1 | tee deployment_log.txt
  artifacts:
    name: "deployment-${CI_COMMIT_SHORT_SHA}"
    paths:
      - deployment_log.txt
    expire_in: 7 days
    when: always
  rules:
    - when: on_success

# ─────────────────────────────────────────────────────────────
# STAGE 5: TEST
# ─────────────────────────────────────────────────────────────

health_check:
  stage: test
  image: curlimages/curl:latest
  dependencies:
    - terraform_apply
  script:
    - SERVER_IP=$(cat ${CI_PROJECT_DIR}/server_ip.txt)
    - echo "=== Running Health Check for http://$SERVER_IP:8055 ==="
    - |
      for i in $(seq 1 10); do
        STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://$SERVER_IP:8055/server/ping)
        echo "Attempt $i/10: HTTP Status $STATUS"
        if [ "$STATUS" = "200" ]; then
          echo "Health check PASSED! Directus is accessible at http://$SERVER_IP:8055"
          echo "STATUS=PASS" > health_check_result.txt
          echo "HTTP_CODE=$STATUS" >> health_check_result.txt
          echo "URL=http://$SERVER_IP:8055" >> health_check_result.txt
          break
        fi
        sleep 15
      done
    - |
      if ! grep -q "STATUS=PASS" health_check_result.txt 2>/dev/null; then
        echo "Health check FAILED after all attempts"
        echo "STATUS=FAIL" > health_check_result.txt
        exit 1
      fi
  artifacts:
    name: "health-check-${CI_COMMIT_SHORT_SHA}"
    paths:
      - health_check_result.txt
    expire_in: 7 days
    when: always
  rules:
    - when: on_success
  allow_failure: false

capture_homepage:
  stage: test
  image: curlimages/curl:latest
  dependencies:
    - terraform_apply
  script:
    - SERVER_IP=$(cat ${CI_PROJECT_DIR}/server_ip.txt)
    - echo "=== Capturing Directus Homepage HTML ==="
    - curl -L -o directus_homepage.html http://$SERVER_IP:8055
    - echo "Homepage captured!"
    - wc -c directus_homepage.html
  artifacts:
    name: "homepage-${CI_COMMIT_SHORT_SHA}"
    paths:
      - directus_homepage.html
    expire_in: 7 days
    when: always
  rules:
    - when: on_success
  allow_failure: true

generate_report:
  stage: test
  image: alpine:latest
  dependencies:
    - terraform_apply
    - health_check
  script:
    - SERVER_IP=$(cat ${CI_PROJECT_DIR}/server_ip.txt || echo "Unknown")
    - DIRECTUS_URL="http://$SERVER_IP:8055"
    - HEALTH_STATUS=$(grep "STATUS=" health_check_result.txt 2>/dev/null | cut -d= -f2 || echo "UNKNOWN")
    - |
      cat > deployment_report.md << EOF
      # Directus Deployment Report
      
      **Pipeline:** ${CI_PIPELINE_ID}
      **Commit:** ${CI_COMMIT_SHORT_SHA}
      **Branch:** ${CI_COMMIT_REF_NAME}
      **Date:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')
      
      ## Infrastructure
      
      | Resource | Value |
      |----------|-------|
      | Cloud Provider | AWS |
      | Region | ${AWS_DEFAULT_REGION} |
      | Instance Type | t2.micro |
      | OS | Ubuntu 22.04 LTS |
      | Server IP | ${SERVER_IP} |
      
      ## Deployment
      
      | Service | Status |
      |---------|--------|
      | Directus CMS | Running |
      | PostgreSQL DB | Running |
      | Docker | Installed via user_data |
      
      ## Access
      
      - **Directus URL:** ${DIRECTUS_URL}
      - **Admin Panel:** ${DIRECTUS_URL}/admin
      
      ## Health Check
      
      - **Status:** ${HEALTH_STATUS}
      - **Endpoint tested:** ${DIRECTUS_URL}/server/ping
      
      ## Pipeline Stages
      
      | Stage | Job | Status |
      |-------|-----|--------|
      | validate | terraform_validate | ✅ |
      | validate | terraform_lint | ✅ |
      | validate | docker_validate | ✅ |
      | plan | terraform_plan | ✅ |
      | provision | terraform_apply | ✅ |
      | deploy | deploy_directus | ✅ |
      | test | health_check | ${HEALTH_STATUS} |
      | test | capture_homepage | ✅ |
      | test | generate_report | ✅ |
      | cleanup | terraform_destroy | ⏸ (manual) |
      EOF
    - cat deployment_report.md
  artifacts:
    name: "deployment-report-${CI_COMMIT_SHORT_SHA}"
    paths:
      - deployment_report.md
    expire_in: 30 days
    when: always
  rules:
    - when: on_success
  allow_failure: true

# ─────────────────────────────────────────────────────────────
# STAGE 6: CLEANUP (MANUAL)
# ─────────────────────────────────────────────────────────────

terraform_destroy:
  stage: cleanup
  image: hashicorp/terraform:latest
  dependencies:
    - terraform_apply
  before_script:
    - cd ${TF_ROOT}
    - terraform init -backend=false
  script:
    - echo "=== Terraform Destroy ==="
    - echo "WARNING: This will destroy all provisioned infrastructure!"
    - terraform destroy
        -var="aws_region=${AWS_DEFAULT_REGION}"
        -var="project_name=directus-cicd"
        -var="instance_type=t2.micro"
        -var="environment=production"
        -auto-approve
        -no-color 2>&1 | tee destroy_output.txt
    - echo "=== All infrastructure has been destroyed ==="
  artifacts:
    name: "terraform-destroy-${CI_COMMIT_SHORT_SHA}"
    paths:
      - terraform/destroy_output.txt
    expire_in: 7 days
    when: always
  rules:
    - when: manual
  allow_failure: false
